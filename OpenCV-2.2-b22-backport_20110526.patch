diff -ur OpenCV-2.2.0/CMakeLists.txt opencv/CMakeLists.txt
--- OpenCV-2.2.0/CMakeLists.txt	2010-12-05 04:35:23.000000000 +0100
+++ opencv/CMakeLists.txt	2011-05-26 12:57:56.452093002 +0200
@@ -1224,6 +1224,11 @@
             DESTINATION "."
             COMPONENT main
             )
+        install(FILES
+            "include/CMakeLists.txt"
+            DESTINATION "include/"
+            COMPONENT src
+            )
 
         if(CMAKE_INSTALL_DEBUG_LIBRARIES)
             foreach(m calib3d core contrib features2d ffmpeg flann gpu highgui imgproc legacy ml objdetect video)
diff -ur OpenCV-2.2.0/cvconfig.h.cmake opencv/cvconfig.h.cmake
--- OpenCV-2.2.0/cvconfig.h.cmake	2010-12-05 04:35:23.000000000 +0100
+++ opencv/cvconfig.h.cmake	2011-05-26 12:57:56.449093002 +0200
@@ -19,6 +19,9 @@
 /* V4L2 capturing support */
 #cmakedefine HAVE_CAMV4L2
 
+/* V4L/V4L2 capturing support via libv4l */
+#cmakedefine HAVE_LIBV4L
+
 /* Carbon windowing environment */
 #cmakedefine HAVE_CARBON
 
diff -ur OpenCV-2.2.0/modules/calib3d/src/fundam.cpp opencv/modules/calib3d/src/fundam.cpp
--- OpenCV-2.2.0/modules/calib3d/src/fundam.cpp	2010-12-05 04:35:24.000000000 +0100
+++ opencv/modules/calib3d/src/fundam.cpp	2011-05-26 12:56:33.457093003 +0200
@@ -269,6 +269,8 @@
         icvCompressPoints( (CvPoint2D64f*)M->data.ptr, tempMask->data.ptr, 1, count );
         count = icvCompressPoints( (CvPoint2D64f*)m->data.ptr, tempMask->data.ptr, 1, count );
         M->cols = m->cols = count;
+        if( method == CV_RANSAC )
+            estimator.runKernel( M, m, &matH );
         estimator.refine( M, m, &matH, 10 );
     }
 
diff -ur OpenCV-2.2.0/modules/core/include/opencv2/core/core.hpp opencv/modules/core/include/opencv2/core/core.hpp
--- OpenCV-2.2.0/modules/core/include/opencv2/core/core.hpp	2010-12-05 04:35:24.000000000 +0100
+++ opencv/modules/core/include/opencv2/core/core.hpp	2011-05-26 12:56:06.028093003 +0200
@@ -1816,7 +1816,7 @@
 class CV_EXPORTS RNG
 {
 public:
-    enum { A=4164903690U, UNIFORM=0, NORMAL=1 };
+    enum { UNIFORM=0, NORMAL=1 };
 
     RNG();
     RNG(uint64 _state);
diff -ur OpenCV-2.2.0/modules/core/include/opencv2/core/mat.hpp opencv/modules/core/include/opencv2/core/mat.hpp
--- OpenCV-2.2.0/modules/core/include/opencv2/core/mat.hpp	2010-12-05 04:35:24.000000000 +0100
+++ opencv/modules/core/include/opencv2/core/mat.hpp	2011-05-26 12:56:06.019093003 +0200
@@ -805,7 +805,7 @@
 
 template<typename _Tp> template<int n> inline
     Mat_<_Tp>::Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData)
-    : Mat(n/DataType<_Tp>::channels, 1, DataType<_Tp>::type, &vec)
+    : Mat(n/DataType<_Tp>::channels, 1, DataType<_Tp>::type, (void*)&vec)
 {
     CV_Assert(n%DataType<_Tp>::channels == 0);
     if( copyData )
@@ -814,7 +814,7 @@
 
 template<typename _Tp> template<int m, int n> inline
     Mat_<_Tp>::Mat_(const Matx<typename DataType<_Tp>::channel_type,m,n>& M, bool copyData)
-    : Mat(m, n/DataType<_Tp>::channels, DataType<_Tp>::type, &M)
+    : Mat(m, n/DataType<_Tp>::channels, DataType<_Tp>::type, (void*)&M)
 {
     CV_Assert(n % DataType<_Tp>::channels == 0);
     if( copyData )
@@ -822,7 +822,7 @@
 }
     
 template<typename _Tp> inline Mat_<_Tp>::Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
-    : Mat(2/DataType<_Tp>::channels, 1, DataType<_Tp>::type, &pt)
+    : Mat(2/DataType<_Tp>::channels, 1, DataType<_Tp>::type, (void*)&pt)
 {
     CV_Assert(2 % DataType<_Tp>::channels == 0);
     if( copyData )
@@ -830,7 +830,7 @@
 }
 
 template<typename _Tp> inline Mat_<_Tp>::Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
-    : Mat(3/DataType<_Tp>::channels, 1, DataType<_Tp>::type, &pt)
+    : Mat(3/DataType<_Tp>::channels, 1, DataType<_Tp>::type, (void*)&pt)
 {
     CV_Assert(3 % DataType<_Tp>::channels == 0);
     if( copyData )
diff -ur OpenCV-2.2.0/modules/core/include/opencv2/core/operations.hpp opencv/modules/core/include/opencv2/core/operations.hpp
--- OpenCV-2.2.0/modules/core/include/opencv2/core/operations.hpp	2010-12-05 04:35:24.000000000 +0100
+++ opencv/modules/core/include/opencv2/core/operations.hpp	2011-05-26 12:56:06.022093003 +0200
@@ -572,6 +572,7 @@
 {
     for( int i = 0; i < m*n; i++ )
         a.val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
+    return a;
 }        
     
 template<typename _Tp, int m, int n> static inline
@@ -579,6 +580,7 @@
 {
     for( int i = 0; i < m*n; i++ )
         a.val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
+    return a;
 }    
 
 template<typename _Tp, int m, int n> static inline
@@ -586,6 +588,7 @@
 {
     for( int i = 0; i < m*n; i++ )
         a.val[i] = saturate_cast<_Tp>(a.val[i] * alpha);
+    return a;
 }        
 
 template<typename _Tp, int m, int n> static inline
@@ -2239,7 +2242,7 @@
 inline RNG::RNG(uint64 _state) { state = _state ? _state : 0xffffffff; }
 inline unsigned RNG::next()
 {
-    state = (uint64)(unsigned)state*A + (unsigned)(state >> 32);
+    state = (uint64)(unsigned)state*CV_RNG_COEFF + (unsigned)(state >> 32);
     return (unsigned)state;
 }
 
diff -ur OpenCV-2.2.0/modules/core/include/opencv2/core/types_c.h opencv/modules/core/include/opencv2/core/types_c.h
--- OpenCV-2.2.0/modules/core/include/opencv2/core/types_c.h	2010-12-05 04:35:24.000000000 +0100
+++ opencv/modules/core/include/opencv2/core/types_c.h	2011-05-26 12:56:06.024093003 +0200
@@ -375,6 +375,8 @@
 
 typedef uint64 CvRNG;
 
+#define CV_RNG_COEFF 4164903690U
+
 CV_INLINE CvRNG cvRNG( int64 seed CV_DEFAULT(-1))
 {
     CvRNG rng = seed ? (uint64)seed : (uint64)(int64)-1;
@@ -385,7 +387,7 @@
 CV_INLINE unsigned cvRandInt( CvRNG* rng )
 {
     uint64 temp = *rng;
-    temp = (uint64)(unsigned)temp*4164903690U + (temp >> 32);
+    temp = (uint64)(unsigned)temp*CV_RNG_COEFF + (temp >> 32);
     *rng = temp;
     return (unsigned)temp;
 }
diff -ur OpenCV-2.2.0/modules/core/src/lapack.cpp opencv/modules/core/src/lapack.cpp
--- OpenCV-2.2.0/modules/core/src/lapack.cpp	2010-12-05 04:35:24.000000000 +0100
+++ opencv/modules/core/src/lapack.cpp	2011-05-26 12:56:13.567093003 +0200
@@ -217,10 +217,10 @@
 *                                 Determinant of the matrix                              *
 \****************************************************************************************/
 
-#define det2(m)   (m(0,0)*m(1,1) - m(0,1)*m(1,0))
-#define det3(m)   (m(0,0)*(m(1,1)*m(2,2) - m(1,2)*m(2,1)) -  \
-                   m(0,1)*(m(1,0)*m(2,2) - m(1,2)*m(2,0)) +  \
-                   m(0,2)*(m(1,0)*m(2,1) - m(1,1)*m(2,0)))
+#define det2(m)   ((double)m(0,0)*m(1,1) - (double)m(0,1)*m(1,0))
+#define det3(m)   (m(0,0)*((double)m(1,1)*m(2,2) - (double)m(1,2)*m(2,1)) -  \
+                   m(0,1)*((double)m(1,0)*m(2,2) - (double)m(1,2)*m(2,0)) +  \
+                   m(0,2)*((double)m(1,0)*m(2,1) - (double)m(1,1)*m(2,0)))
 
 double determinant( const Mat& mat )
 {
@@ -405,17 +405,17 @@
                     result = d;
                     d = 1./d;
 
-                    t[0] = (float)((Sf(1,1) * Sf(2,2) - Sf(1,2) * Sf(2,1)) * d);
-                    t[1] = (float)((Sf(0,2) * Sf(2,1) - Sf(0,1) * Sf(2,2)) * d);
-                    t[2] = (float)((Sf(0,1) * Sf(1,2) - Sf(0,2) * Sf(1,1)) * d);
-                                  
-                    t[3] = (float)((Sf(1,2) * Sf(2,0) - Sf(1,0) * Sf(2,2)) * d);
-                    t[4] = (float)((Sf(0,0) * Sf(2,2) - Sf(0,2) * Sf(2,0)) * d);
-                    t[5] = (float)((Sf(0,2) * Sf(1,0) - Sf(0,0) * Sf(1,2)) * d);
-                                  
-                    t[6] = (float)((Sf(1,0) * Sf(2,1) - Sf(1,1) * Sf(2,0)) * d);
-                    t[7] = (float)((Sf(0,1) * Sf(2,0) - Sf(0,0) * Sf(2,1)) * d);
-                    t[8] = (float)((Sf(0,0) * Sf(1,1) - Sf(0,1) * Sf(1,0)) * d);
+                    t[0] = (float)(((double)Sf(1,1) * Sf(2,2) - (double)Sf(1,2) * Sf(2,1)) * d);
+                    t[1] = (float)(((double)Sf(0,2) * Sf(2,1) - (double)Sf(0,1) * Sf(2,2)) * d);
+                    t[2] = (float)(((double)Sf(0,1) * Sf(1,2) - (double)Sf(0,2) * Sf(1,1)) * d);
+                           
+                    t[3] = (float)(((double)Sf(1,2) * Sf(2,0) - (double)Sf(1,0) * Sf(2,2)) * d);
+                    t[4] = (float)(((double)Sf(0,0) * Sf(2,2) - (double)Sf(0,2) * Sf(2,0)) * d);
+                    t[5] = (float)(((double)Sf(0,2) * Sf(1,0) - (double)Sf(0,0) * Sf(1,2)) * d);
+                           
+                    t[6] = (float)(((double)Sf(1,0) * Sf(2,1) - (double)Sf(1,1) * Sf(2,0)) * d);
+                    t[7] = (float)(((double)Sf(0,1) * Sf(2,0) - (double)Sf(0,0) * Sf(2,1)) * d);
+                    t[8] = (float)(((double)Sf(0,0) * Sf(1,1) - (double)Sf(0,1) * Sf(1,0)) * d);
 
                     Df(0,0) = t[0]; Df(0,1) = t[1]; Df(0,2) = t[2];
                     Df(1,0) = t[3]; Df(1,1) = t[4]; Df(1,2) = t[5];
@@ -607,10 +607,10 @@
                 double d = det2(Sf);
                 if( d != 0. )
                 {
-                    float t;
+                    double t;
                     d = 1./d;
-                    t = (float)((bf(0)*Sf(1,1) - bf(1)*Sf(0,1))*d);
-                    Df(1,0) = (float)((bf(1)*Sf(0,0) - bf(0)*Sf(1,0))*d);
+                    t = (float)(((double)bf(0)*Sf(1,1) - (double)bf(1)*Sf(0,1))*d);
+                    Df(1,0) = (float)(((double)bf(1)*Sf(0,0) - (double)bf(0)*Sf(1,0))*d);
                     Df(0,0) = t;
                 }
                 else
@@ -642,19 +642,19 @@
                     d = 1./d;
 
                     t[0] = (float)(d*
-                           (bf(0)*(Sf(1,1)*Sf(2,2) - Sf(1,2)*Sf(2,1)) -
-                            Sf(0,1)*(bf(1)*Sf(2,2) - Sf(1,2)*bf(2)) +
-                            Sf(0,2)*(bf(1)*Sf(2,1) - Sf(1,1)*bf(2))));
+                           (bf(0)*((double)Sf(1,1)*Sf(2,2) - (double)Sf(1,2)*Sf(2,1)) -
+                            Sf(0,1)*((double)bf(1)*Sf(2,2) - (double)Sf(1,2)*bf(2)) +
+                            Sf(0,2)*((double)bf(1)*Sf(2,1) - (double)Sf(1,1)*bf(2))));
 
                     t[1] = (float)(d*
-                           (Sf(0,0)*(bf(1)*Sf(2,2) - Sf(1,2)*bf(2)) -
-                            bf(0)*(Sf(1,0)*Sf(2,2) - Sf(1,2)*Sf(2,0)) +
-                            Sf(0,2)*(Sf(1,0)*bf(2) - bf(1)*Sf(2,0))));
+                           (Sf(0,0)*(double)(bf(1)*Sf(2,2) - (double)Sf(1,2)*bf(2)) -
+                            bf(0)*((double)Sf(1,0)*Sf(2,2) - (double)Sf(1,2)*Sf(2,0)) +
+                            Sf(0,2)*((double)Sf(1,0)*bf(2) - (double)bf(1)*Sf(2,0))));
 
                     t[2] = (float)(d*
-                           (Sf(0,0)*(Sf(1,1)*bf(2) - bf(1)*Sf(2,1)) -
-                            Sf(0,1)*(Sf(1,0)*bf(2) - bf(1)*Sf(2,0)) +
-                            bf(0)*(Sf(1,0)*Sf(2,1) - Sf(1,1)*Sf(2,0))));
+                           (Sf(0,0)*((double)Sf(1,1)*bf(2) - (double)bf(1)*Sf(2,1)) -
+                            Sf(0,1)*((double)Sf(1,0)*bf(2) - (double)bf(1)*Sf(2,0)) +
+                            bf(0)*((double)Sf(1,0)*Sf(2,1) - (double)Sf(1,1)*Sf(2,0))));
 
                     Df(0,0) = t[0];
                     Df(1,0) = t[1];
diff -ur OpenCV-2.2.0/modules/core/src/mathfuncs.cpp opencv/modules/core/src/mathfuncs.cpp
--- OpenCV-2.2.0/modules/core/src/mathfuncs.cpp	2010-12-05 04:35:24.000000000 +0100
+++ opencv/modules/core/src/mathfuncs.cpp	2011-05-26 12:56:13.564093003 +0200
@@ -773,7 +773,8 @@
 
 
 // the code below uses _mm_cast* intrinsics, which are not avialable on VS2005
-#if defined _MSC_VER && _MSC_VER < 1500
+#if (defined _MSC_VER && _MSC_VER < 1500) || \
+    (!defined __APPLE__ && defined __GNUC__ && __GNUC__*100 + __GNUC_MINOR__ < 402)
 #undef CV_SSE2
 #define CV_SSE2 0
 #endif    
diff -ur OpenCV-2.2.0/modules/core/src/rand.cpp opencv/modules/core/src/rand.cpp
--- OpenCV-2.2.0/modules/core/src/rand.cpp	2010-12-05 04:35:24.000000000 +0100
+++ opencv/modules/core/src/rand.cpp	2011-05-26 12:56:13.556093003 +0200
@@ -60,7 +60,7 @@
    carry = temp / (2^32)
 */
 
-#define  RNG_NEXT(x)    ((uint64)(unsigned)(x)*RNG::A + ((x) >> 32))
+#define  RNG_NEXT(x)    ((uint64)(unsigned)(x)*CV_RNG_COEFF + ((x) >> 32))
 
 /***************************************************************************************\
 *                           Pseudo-Random Number Generators (PRNGs)                     *
diff -ur OpenCV-2.2.0/modules/features2d/src/sift.cpp opencv/modules/features2d/src/sift.cpp
--- OpenCV-2.2.0/modules/features2d/src/sift.cpp	2010-12-05 04:35:24.000000000 +0100
+++ opencv/modules/features2d/src/sift.cpp	2011-05-26 12:56:40.354093002 +0200
@@ -48,14 +48,15 @@
 
 #include "precomp.hpp"
 
-#ifdef __arm__
-#define ARM_NO_SIFT
-#endif
-
-#ifdef ANDROID
-#undef  ARM_NO_SIFT
-#endif //ANDROID
+//#ifdef __arm__
+//#define ARM_NO_SIFT
+//#endif
+
+//#ifdef ANDROID
+//#undef  ARM_NO_SIFT
+//#endif //ANDROID
 
+#undef ARM_NO_SIFT
 #ifndef ARM_NO_SIFT
 
 #include <iostream>
diff -ur OpenCV-2.2.0/modules/ffmpeg/CMakeLists.txt opencv/modules/ffmpeg/CMakeLists.txt
--- OpenCV-2.2.0/modules/ffmpeg/CMakeLists.txt	2010-12-05 04:35:24.000000000 +0100
+++ opencv/modules/ffmpeg/CMakeLists.txt	2011-05-26 12:56:40.932093003 +0200
@@ -45,6 +45,7 @@
                       DEFINE_SYMBOL "CVAPI_EXPORTS"
                       ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib/"
                       RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin/"
+                      LINK_FLAGS "/NODEFAULTLIB:libc /DEBUG"
                       )
 
 install(TARGETS ${the_target}
diff -ur OpenCV-2.2.0/modules/gpu/src/cuda/stereobm.cu opencv/modules/gpu/src/cuda/stereobm.cu
--- OpenCV-2.2.0/modules/gpu/src/cuda/stereobm.cu	2010-12-05 04:35:24.000000000 +0100
+++ opencv/modules/gpu/src/cuda/stereobm.cu	2011-05-26 12:56:18.309093002 +0200
@@ -252,7 +252,7 @@
         for(uint *ptr = minSSDImage; ptr != minSSDImage_end; ptr += minssd_step )
             *ptr = 0xFFFFFFFF;
     }*/
-    int end_row = min(ROWSperTHREAD, cheight - Y);
+    int end_row = min(ROWSperTHREAD, cheight - Y - RADIUS);
     int y_tex;
     int x_tex = X - RADIUS;
 
diff -ur OpenCV-2.2.0/modules/gpu/src/stereobm_gpu.cpp opencv/modules/gpu/src/stereobm_gpu.cpp
--- OpenCV-2.2.0/modules/gpu/src/stereobm_gpu.cpp	2010-12-05 04:35:24.000000000 +0100
+++ opencv/modules/gpu/src/stereobm_gpu.cpp	2011-05-26 12:56:18.468093002 +0200
@@ -62,7 +62,7 @@
     {
         //extern "C" void stereoBM_GPU(const DevMem2D& left, const DevMem2D& right, const DevMem2D& disp, int ndisp, int winsz, const DevMem2D_<uint>& minSSD_buf);
         extern "C" void stereoBM_GPU(const DevMem2D& left, const DevMem2D& right, const DevMem2D& disp, int ndisp, int winsz, const DevMem2D_<uint>& minSSD_buf, cudaStream_t & stream);
-        extern "C" void prefilter_xsobel(const DevMem2D& input, const DevMem2D output, int prefilterCap /*= 31*/, cudaStream_t & stream);
+        extern "C" void prefilter_xsobel(const DevMem2D& input, const DevMem2D& output, int prefilterCap /*= 31*/, cudaStream_t & stream);
         extern "C" void postfilter_textureness(const DevMem2D& input, int winsz, float avgTexturenessThreshold, const DevMem2D& disp, cudaStream_t & stream);
     }
 }}
diff -ur OpenCV-2.2.0/modules/highgui/CMakeLists.txt opencv/modules/highgui/CMakeLists.txt
--- OpenCV-2.2.0/modules/highgui/CMakeLists.txt	2010-12-05 04:35:24.000000000 +0100
+++ opencv/modules/highgui/CMakeLists.txt	2011-05-26 12:56:02.807093003 +0200
@@ -257,7 +257,7 @@
 	)
 
 if(MSVC)
-	set_target_properties(${the_target} PROPERTIES LINK_FLAGS "/NODEFAULTLIB:atlthunk.lib")
+	set_target_properties(${the_target} PROPERTIES LINK_FLAGS "/NODEFAULTLIB:atlthunk.lib /NODEFAULTLIB:atlsd.lib /DEBUG")
 endif(MSVC)
 
 # Dependencies of this target:
diff -ur OpenCV-2.2.0/modules/highgui/src/cap.cpp opencv/modules/highgui/src/cap.cpp
--- OpenCV-2.2.0/modules/highgui/src/cap.cpp	2010-12-05 04:35:24.000000000 +0100
+++ opencv/modules/highgui/src/cap.cpp	2011-05-26 12:56:02.770093003 +0200
@@ -52,10 +52,10 @@
 namespace cv
 {
 
-template<> inline void Ptr<CvCapture>::delete_obj()
+template<> void Ptr<CvCapture>::delete_obj()
 { cvReleaseCapture(&obj); }
 
-template<> inline void Ptr<CvVideoWriter>::delete_obj()
+template<> void Ptr<CvVideoWriter>::delete_obj()
 { cvReleaseVideoWriter(&obj); }
 
 }
@@ -171,7 +171,7 @@
             if (capture)
                 return capture;
         #endif
-        #if defined (HAVE_CAMV4L) || defined (HAVE_CAMV4L2)
+        #if defined HAVE_LIBV4L || (defined (HAVE_CAMV4L) && defined (HAVE_CAMV4L2))
             capture = cvCreateCameraCapture_V4L (index);
             if (capture)
                 return capture;
diff -ur OpenCV-2.2.0/modules/highgui/src/cap_dshow.cpp opencv/modules/highgui/src/cap_dshow.cpp
--- OpenCV-2.2.0/modules/highgui/src/cap_dshow.cpp	2010-12-05 04:35:25.000000000 +0100
+++ opencv/modules/highgui/src/cap_dshow.cpp	2011-05-26 12:56:02.789093003 +0200
@@ -184,6 +184,7 @@
 }
 
 #ifdef _MSC_VER
+#pragma comment(lib, "strmiids.lib")
 #if defined _M_X64
 #pragma comment(lib, "videoInput64.lib")
 #else
diff -ur OpenCV-2.2.0/modules/highgui/src/cap_libv4l.cpp opencv/modules/highgui/src/cap_libv4l.cpp
--- OpenCV-2.2.0/modules/highgui/src/cap_libv4l.cpp	2010-12-05 04:35:25.000000000 +0100
+++ opencv/modules/highgui/src/cap_libv4l.cpp	2011-05-26 12:56:02.796093003 +0200
@@ -224,7 +224,7 @@
 #include "highgui.h"
 #include "precomp.hpp"
 
-#if !defined WIN32 && defined HAVE_CAMV4L && defined HAVE_CAMV4L2
+#if !defined WIN32 && defined HAVE_LIBV4L
 
 #define CLEAR(x) memset (&(x), 0, sizeof (x))
 
@@ -241,8 +241,12 @@
 #include <sys/stat.h>
 #include <sys/ioctl.h>
 
+#ifdef HAVE_CAMV4L
 #include <linux/videodev.h>
+#endif
+#ifdef HAVE_CAMV4L2
 #include <linux/videodev2.h>
+#endif
 
 #include <libv4l1.h>
 #include <libv4l2.h>
diff -ur OpenCV-2.2.0/modules/highgui/src/grfmt_png.cpp opencv/modules/highgui/src/grfmt_png.cpp
--- OpenCV-2.2.0/modules/highgui/src/grfmt_png.cpp	2010-12-05 04:35:25.000000000 +0100
+++ opencv/modules/highgui/src/grfmt_png.cpp	2011-05-26 12:56:02.797093003 +0200
@@ -223,8 +223,12 @@
                 png_set_palette_to_rgb( png_ptr );
 
             if( m_color_type == PNG_COLOR_TYPE_GRAY && m_bit_depth < 8 )
+#if PNG_LIBPNG_VER_MAJOR*100 + PNG_LIBPNG_VER_MINOR >= 104
                 png_set_expand_gray_1_2_4_to_8( png_ptr );
-
+#else
+                png_set_gray_1_2_4_to_8( png_ptr );
+#endif
+            
             if( CV_MAT_CN(m_type) > 1 && color )
                 png_set_bgr( png_ptr ); // convert RGB to BGR
             else if( color )
diff -ur OpenCV-2.2.0/modules/highgui/src/precomp.hpp opencv/modules/highgui/src/precomp.hpp
--- OpenCV-2.2.0/modules/highgui/src/precomp.hpp	2010-12-05 04:35:25.000000000 +0100
+++ opencv/modules/highgui/src/precomp.hpp	2011-05-26 12:56:02.793093003 +0200
@@ -58,9 +58,8 @@
 #include <ctype.h>
 #include <assert.h>
 
-#if !defined WIN32 && !defined _WIN32
 #include "cvconfig.h"
-#else
+#if defined WIN32 || defined _WIN32
 void  FillBitmapInfo( BITMAPINFO* bmi, int width, int height, int bpp, int origin );
 #endif
 
diff -ur OpenCV-2.2.0/modules/imgproc/include/opencv2/imgproc/imgproc.hpp opencv/modules/imgproc/include/opencv2/imgproc/imgproc.hpp
--- OpenCV-2.2.0/modules/imgproc/include/opencv2/imgproc/imgproc.hpp	2010-12-05 04:35:25.000000000 +0100
+++ opencv/modules/imgproc/include/opencv2/imgproc/imgproc.hpp	2011-05-26 12:56:22.594093003 +0200
@@ -348,8 +348,10 @@
                                               bool normalize=true,
                                               int borderType=BORDER_DEFAULT);
 //! type of morphological operation
-enum { MORPH_ERODE=0, MORPH_DILATE=1, MORPH_OPEN=2, MORPH_CLOSE=3,
-       MORPH_GRADIENT=4, MORPH_TOPHAT=5, MORPH_BLACKHAT=6 };
+enum { MORPH_ERODE=CV_MOP_ERODE, MORPH_DILATE=CV_MOP_DILATE,
+       MORPH_OPEN=CV_MOP_OPEN, MORPH_CLOSE=CV_MOP_CLOSE,
+       MORPH_GRADIENT=CV_MOP_GRADIENT, MORPH_TOPHAT=CV_MOP_TOPHAT,
+       MORPH_BLACKHAT=CV_MOP_BLACKHAT };
 
 //! returns horizontal 1D morphological filter
 CV_EXPORTS Ptr<BaseRowFilter> getMorphologyRowFilter(int op, int type, int ksize, int anchor=-1);
@@ -500,13 +502,13 @@
 //! interpolation algorithm
 enum
 {
-    INTER_NEAREST=0, //!< nearest neighbor interpolation
-    INTER_LINEAR=1, //!< bilinear interpolation
-    INTER_CUBIC=2, //!< bicubic interpolation
-    INTER_AREA=3, //!< area-based (or super) interpolation
-    INTER_LANCZOS4=4, //!< Lanczos interpolation over 8x8 neighborhood
+    INTER_NEAREST=CV_INTER_NN, //!< nearest neighbor interpolation
+    INTER_LINEAR=CV_INTER_LINEAR, //!< bilinear interpolation
+    INTER_CUBIC=CV_INTER_CUBIC, //!< bicubic interpolation
+    INTER_AREA=CV_INTER_AREA, //!< area-based (or super) interpolation
+    INTER_LANCZOS4=CV_INTER_LANCZOS4, //!< Lanczos interpolation over 8x8 neighborhood
     INTER_MAX=7,
-    WARP_INVERSE_MAP=16
+    WARP_INVERSE_MAP=CV_WARP_INVERSE_MAP
 };
 
 //! resizes the image
@@ -574,8 +576,10 @@
                                       double alpha, const Mat& mask=Mat() );
     
 //! type of the threshold operation
-enum { THRESH_BINARY=0, THRESH_BINARY_INV=1, THRESH_TRUNC=2, THRESH_TOZERO=3,
-       THRESH_TOZERO_INV=4, THRESH_MASK=7, THRESH_OTSU=8 };
+enum { THRESH_BINARY=CV_THRESH_BINARY, THRESH_BINARY_INV=CV_THRESH_BINARY_INV,
+       THRESH_TRUNC=CV_THRESH_TRUNC, THRESH_TOZERO=CV_THRESH_TOZERO,
+       THRESH_TOZERO_INV=CV_THRESH_TOZERO_INV, THRESH_MASK=CV_THRESH_MASK,
+       THRESH_OTSU=CV_THRESH_OTSU };
 
 //! applies fixed threshold to the image
 CV_EXPORTS_W double threshold( const Mat& src, CV_OUT Mat& dst, double thresh, double maxval, int type );
@@ -672,17 +676,21 @@
                     TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) );
 
 //! class of the pixel in GrabCut algorithm
-enum { GC_BGD    = 0,  //!< background
-       GC_FGD    = 1,  //!< foreground
-       GC_PR_BGD = 2,  //!< most probably background
-       GC_PR_FGD = 3   //!< most probably foreground 
-     };
+enum
+{
+    GC_BGD    = 0,  //!< background
+    GC_FGD    = 1,  //!< foreground
+    GC_PR_BGD = 2,  //!< most probably background
+    GC_PR_FGD = 3   //!< most probably foreground 
+};
 
 //! GrabCut algorithm flags
-enum { GC_INIT_WITH_RECT  = 0,
-       GC_INIT_WITH_MASK  = 1,
-       GC_EVAL            = 2
-     };
+enum
+{
+    GC_INIT_WITH_RECT  = 0,
+    GC_INIT_WITH_MASK  = 1,
+    GC_EVAL            = 2
+};
 
 //! segments the image using GrabCut algorithm
 CV_EXPORTS_W void grabCut( const Mat& img, Mat& mask, Rect rect, 
@@ -692,8 +700,8 @@
 //! the inpainting algorithm
 enum
 {
-    INPAINT_NS=0, // Navier-Stokes algorithm
-    INPAINT_TELEA=1 // A. Telea algorithm
+    INPAINT_NS=CV_INPAINT_NS, // Navier-Stokes algorithm
+    INPAINT_TELEA=CV_INPAINT_TELEA // A. Telea algorithm
 };
 
 //! restores the damaged image areas using one of the available intpainting algorithms
@@ -764,19 +772,19 @@
 //! mode of the contour retrieval algorithm
 enum
 {
-    RETR_EXTERNAL=0, //!< retrieve only the most external (top-level) contours
-    RETR_LIST=1, //!< retrieve all the contours without any hierarchical information
-    RETR_CCOMP=2, //!< retrieve the connected components (that can possibly be nested)
-    RETR_TREE=3 //!< retrieve all the contours and the whole hierarchy
+    RETR_EXTERNAL=CV_RETR_EXTERNAL, //!< retrieve only the most external (top-level) contours
+    RETR_LIST=CV_RETR_LIST, //!< retrieve all the contours without any hierarchical information
+    RETR_CCOMP=CV_RETR_CCOMP, //!< retrieve the connected components (that can possibly be nested)
+    RETR_TREE=CV_RETR_TREE //!< retrieve all the contours and the whole hierarchy
 };
 
 //! the contour approximation algorithm
 enum
 {
-    CHAIN_APPROX_NONE=0,
-    CHAIN_APPROX_SIMPLE=1,
-    CHAIN_APPROX_TC89_L1=2,
-    CHAIN_APPROX_TC89_KCOS=3
+    CHAIN_APPROX_NONE=CV_CHAIN_APPROX_NONE,
+ 	CHAIN_APPROX_SIMPLE=CV_CHAIN_APPROX_SIMPLE,
+ 	CHAIN_APPROX_TC89_L1=CV_CHAIN_APPROX_TC89_L1,
+ 	CHAIN_APPROX_TC89_KCOS=CV_CHAIN_APPROX_TC89_KCOS
 };
 
 //! retrieves contours and the hierarchical information from black-n-white image.
diff -ur OpenCV-2.2.0/modules/imgproc/include/opencv2/imgproc/types_c.h opencv/modules/imgproc/include/opencv2/imgproc/types_c.h
--- OpenCV-2.2.0/modules/imgproc/include/opencv2/imgproc/types_c.h	2010-12-05 04:35:25.000000000 +0100
+++ opencv/modules/imgproc/include/opencv2/imgproc/types_c.h	2011-05-26 12:56:22.595093003 +0200
@@ -221,6 +221,11 @@
     CV_YUV2BGR      = 84,
     CV_YUV2RGB      = 85,
     
+    CV_BayerBG2GRAY = 86,
+    CV_BayerGB2GRAY = 87,
+    CV_BayerRG2GRAY = 88,
+    CV_BayerGR2GRAY = 89,
+    
     CV_COLORCVT_MAX  =100
 };
 
diff -ur OpenCV-2.2.0/modules/imgproc/src/color.cpp opencv/modules/imgproc/src/color.cpp
--- OpenCV-2.2.0/modules/imgproc/src/color.cpp	2010-12-05 04:35:25.000000000 +0100
+++ opencv/modules/imgproc/src/color.cpp	2011-05-26 12:56:30.454093002 +0200
@@ -1738,6 +1738,147 @@
         
 //////////////////////////// Bayer Pattern -> RGB conversion /////////////////////////////
 
+static void Bayer2Gray_8u( const Mat& srcmat, Mat& dstmat, int code )
+{
+    const int R2Y = 4899;
+    const int G2Y = 9617;
+    const int B2Y = 1868;
+    const int SHIFT = 14;
+    
+    const uchar* bayer0 = srcmat.data;
+    int bayer_step = (int)srcmat.step;
+    uchar* dst0 = dstmat.data;
+    int dst_step = (int)dstmat.step;
+    Size size = srcmat.size();
+    int bcoeff = B2Y, rcoeff = R2Y;
+    int start_with_green = code == CV_BayerGB2GRAY || code == CV_BayerGR2GRAY;
+    bool brow = true;
+#if CV_SSE2    
+    bool haveSSE2 = checkHardwareSupport(CV_CPU_SSE2);
+#endif
+    
+    if( code != CV_BayerBG2GRAY && code != CV_BayerGB2GRAY )
+    {
+        brow = false;
+        std::swap(bcoeff, rcoeff);
+    }
+    
+    dst0 += dst_step + 1;
+    size.height -= 2;
+    size.width -= 2;
+    
+    for( ; size.height-- > 0; bayer0 += bayer_step, dst0 += dst_step )
+    {
+        int t0, t1, t2;
+        const uchar* bayer = bayer0;
+        uchar* dst = dst0;
+        const uchar* bayer_end = bayer + size.width;
+        
+        if( size.width <= 0 )
+        {
+            dst[-1] = dst[size.width] = 0;
+            continue;
+        }
+        
+        if( start_with_green )
+        {
+            t0 = (bayer[1] + bayer[bayer_step*2+1])*rcoeff;
+            t1 = (bayer[bayer_step] + bayer[bayer_step+2])*bcoeff;
+            t2 = bayer[bayer_step+1]*(2*G2Y);
+            
+            dst[0] = (uchar)CV_DESCALE(t0 + t1 + t2, SHIFT+1);
+            bayer++;
+            dst++;
+        }
+        
+#if CV_SSE2
+        if( haveSSE2 )
+        {
+            __m128i _b2y = _mm_set1_epi16((short)(rcoeff*2));
+            __m128i _g2y = _mm_set1_epi16((short)(G2Y*2));
+            __m128i _r2y = _mm_set1_epi16((short)(bcoeff*2));
+            
+            for( ; bayer <= bayer_end - 18; bayer += 14, dst += 14 )
+            {
+                __m128i r0 = _mm_loadu_si128((const __m128i*)bayer);
+                __m128i r1 = _mm_loadu_si128((const __m128i*)(bayer+bayer_step));
+                __m128i r2 = _mm_loadu_si128((const __m128i*)(bayer+bayer_step*2));
+                
+                __m128i b1 = _mm_add_epi16(_mm_srli_epi16(_mm_slli_epi16(r0, 8), 8),
+                                           _mm_srli_epi16(_mm_slli_epi16(r2, 8), 8));
+                __m128i b0 = _mm_add_epi16(b1, _mm_srli_si128(b1, 2));
+                b1 = _mm_slli_epi16(_mm_srli_si128(b1, 2), 1);
+                
+                __m128i g0 = _mm_add_epi16(_mm_srli_epi16(r0, 8), _mm_srli_epi16(r2, 8));
+                __m128i g1 = _mm_srli_epi16(_mm_slli_epi16(r1, 8), 8);
+                g0 = _mm_add_epi16(g0, _mm_add_epi16(g1, _mm_srli_si128(g1, 2)));
+                g1 = _mm_slli_epi16(_mm_srli_si128(g1, 2), 2);
+                
+                r0 = _mm_srli_epi16(r1, 8);
+                r1 = _mm_slli_epi16(_mm_add_epi16(r0, _mm_srli_si128(r0, 2)), 1);
+                r0 = _mm_slli_epi16(r0, 2);
+                
+                g0 = _mm_add_epi16(_mm_mulhi_epi16(b0, _b2y), _mm_mulhi_epi16(g0, _g2y));
+                g1 = _mm_add_epi16(_mm_mulhi_epi16(b1, _b2y), _mm_mulhi_epi16(g1, _g2y));
+                g0 = _mm_add_epi16(g0, _mm_mulhi_epi16(r0, _r2y));
+                g1 = _mm_add_epi16(g1, _mm_mulhi_epi16(r1, _r2y));
+                g0 = _mm_srli_epi16(g0, 1);
+                g1 = _mm_srli_epi16(g1, 1);
+                g0 = _mm_packus_epi16(g0, g0);
+                g1 = _mm_packus_epi16(g1, g1);
+                g0 = _mm_unpacklo_epi8(g0, g1);
+                _mm_storeu_si128((__m128i*)dst, g0);
+            }
+        }
+#endif
+        
+        for( ; bayer <= bayer_end - 2; bayer += 2, dst += 2 )
+        {
+            t0 = (bayer[0] + bayer[2] + bayer[bayer_step*2] + bayer[bayer_step*2+2])*rcoeff;
+            t1 = (bayer[1] + bayer[bayer_step] + bayer[bayer_step+2] + bayer[bayer_step*2+1])*G2Y;
+            t2 = bayer[bayer_step+1]*(4*bcoeff);
+            dst[0] = (uchar)CV_DESCALE(t0 + t1 + t2, SHIFT+2);
+            
+            t0 = (bayer[2] + bayer[bayer_step*2+2])*rcoeff;
+            t1 = (bayer[bayer_step+1] + bayer[bayer_step+3])*bcoeff;
+            t2 = bayer[bayer_step+2]*(2*G2Y);
+            dst[1] = (uchar)CV_DESCALE(t0 + t1 + t2, SHIFT+1);
+        }
+        
+        if( bayer < bayer_end )
+        {
+            t0 = (bayer[0] + bayer[2] + bayer[bayer_step*2] + bayer[bayer_step*2+2])*rcoeff;
+            t1 = (bayer[1] + bayer[bayer_step] + bayer[bayer_step+2] + bayer[bayer_step*2+1])*G2Y;
+            t2 = bayer[bayer_step+1]*(4*bcoeff);
+            dst[0] = (uchar)CV_DESCALE(t0 + t1 + t2, SHIFT+2);
+            bayer++;
+            dst++;
+        }
+        
+        dst0[-1] = dst0[0];
+        dst0[size.width] = dst0[size.width-1];
+        
+        brow = !brow;
+        std::swap(bcoeff, rcoeff);
+        start_with_green = !start_with_green;
+    }
+    
+    size = dstmat.size();
+    dst0 = dstmat.data;
+    if( size.height > 2 )
+        for( int i = 0; i < size.width; i++ )
+        {
+            dst0[i] = dst0[i + dst_step];
+            dst0[i + (size.height-1)*dst_step] = dst0[i + (size.height-2)*dst_step];
+        }
+    else
+        for( int i = 0; i < size.width; i++ )
+        {
+            dst0[i] = dst0[i + (size.height-1)*dst_step] = 0;
+        }
+}
+
+
 static void Bayer2RGB_8u( const Mat& srcmat, Mat& dstmat, int code )
 {
     const uchar* bayer0 = srcmat.data;
@@ -1747,26 +1888,28 @@
     Size size = srcmat.size();
     int blue = code == CV_BayerBG2BGR || code == CV_BayerGB2BGR ? -1 : 1;
     int start_with_green = code == CV_BayerGB2BGR || code == CV_BayerGR2BGR;
-
-    memset( dst0, 0, size.width*3*sizeof(dst0[0]) );
-    memset( dst0 + (size.height - 1)*dst_step, 0, size.width*3*sizeof(dst0[0]) );
+#if CV_SSE2
+    bool haveSSE2 = checkHardwareSupport(CV_CPU_SSE2);
+#endif
+    
     dst0 += dst_step + 3 + 1;
     size.height -= 2;
     size.width -= 2;
-
+        
     for( ; size.height-- > 0; bayer0 += bayer_step, dst0 += dst_step )
     {
         int t0, t1;
         const uchar* bayer = bayer0;
         uchar* dst = dst0;
         const uchar* bayer_end = bayer + size.width;
-
-        dst[-4] = dst[-3] = dst[-2] = dst[size.width*3-1] =
-            dst[size.width*3] = dst[size.width*3+1] = 0;
-
+        
         if( size.width <= 0 )
+        {
+            dst[-4] = dst[-3] = dst[-2] = dst[size.width*3-1] =
+            dst[size.width*3] = dst[size.width*3+1] = 0;
             continue;
-
+        }
+        
         if( start_with_green )
         {
             t0 = (bayer[1] + bayer[bayer_step*2+1] + 1) >> 1;
@@ -1777,7 +1920,87 @@
             bayer++;
             dst += 3;
         }
-
+        
+#if CV_SSE2
+        if( haveSSE2 )
+        {
+            /*
+             B G B G | B G B G | B G B G | B G B G
+             G R G R | G R G R | G R G R | G R G R
+             B G B G | B G B G | B G B G | B G B G
+             */
+            __m128i delta1 = _mm_set1_epi16(1), delta2 = _mm_set1_epi16(2);
+            __m128i mask = _mm_set1_epi16(blue < 0 ? -1 : 0), z = _mm_setzero_si128();
+            __m128i masklo = _mm_set1_epi16(0x00ff);
+            
+            for( ; bayer <= bayer_end - 18; bayer += 14, dst += 42 )
+            {
+                __m128i r0 = _mm_loadu_si128((const __m128i*)bayer);
+                __m128i r1 = _mm_loadu_si128((const __m128i*)(bayer+bayer_step));
+                __m128i r2 = _mm_loadu_si128((const __m128i*)(bayer+bayer_step*2));
+                
+                __m128i b1 = _mm_add_epi16(_mm_and_si128(r0, masklo), _mm_and_si128(r2, masklo));
+                __m128i b0 = _mm_add_epi16(b1, _mm_srli_si128(b1, 2));
+                b1 = _mm_srli_si128(b1, 2);
+                b1 = _mm_srli_epi16(_mm_add_epi16(b1, delta1), 1);
+                b0 = _mm_srli_epi16(_mm_add_epi16(b0, delta2), 2);
+                b0 = _mm_packus_epi16(b0, b1);
+                
+                __m128i g0 = _mm_add_epi16(_mm_srli_epi16(r0, 8), _mm_srli_epi16(r2, 8));
+                __m128i g1 = _mm_and_si128(r1, masklo);
+                g0 = _mm_add_epi16(g0, _mm_add_epi16(g1, _mm_srli_si128(g1, 2)));
+                g1 = _mm_srli_si128(g1, 2);
+                g0 = _mm_srli_epi16(_mm_add_epi16(g0, delta2), 2);
+                g0 = _mm_packus_epi16(g0, g1);
+                
+                r0 = _mm_srli_epi16(r1, 8);
+                r1 = _mm_add_epi16(r0, _mm_srli_si128(r0, 2));
+                r1 = _mm_srli_epi16(_mm_add_epi16(r1, delta1), 1);
+                r0 = _mm_packus_epi16(r0, r1);
+                
+                b1 = _mm_and_si128(_mm_xor_si128(b0, r0), mask);
+                b0 = _mm_xor_si128(b0, b1);
+                r0 = _mm_xor_si128(r0, b1);
+                
+                // b1 g1 b1 g1 ...
+                b1 = _mm_unpackhi_epi8(b0, g0);
+                // b0 g0 b2 g2 b4 g4 ....
+                b0 = _mm_unpacklo_epi8(b0, g0);
+                
+                // r1 0 r3 0 ...
+                r1 = _mm_unpackhi_epi8(r0, z);
+                // r0 0 r2 0 r4 0 ...
+                r0 = _mm_unpacklo_epi8(r0, z);
+                
+                // 0 b0 g0 r0 0 b2 g2 r2 0 ...
+                g0 = _mm_slli_si128(_mm_unpacklo_epi16(b0, r0), 1);
+                // 0 b8 g8 r8 0 b10 g10 r10 0 ...
+                g1 = _mm_slli_si128(_mm_unpackhi_epi16(b0, r0), 1);
+                
+                // b1 g1 r1 0 b3 g3 r3 ....
+                r0 = _mm_unpacklo_epi16(b1, r1);
+                // b9 g9 r9 0 ...
+                r1 = _mm_unpackhi_epi16(b1, r1);
+                
+                b0 = _mm_srli_si128(_mm_unpacklo_epi32(g0, r0), 1);
+                b1 = _mm_srli_si128(_mm_unpackhi_epi32(g0, r0), 1);
+                
+                _mm_storel_epi64((__m128i*)(dst-1+0), b0);
+                _mm_storel_epi64((__m128i*)(dst-1+6*1), _mm_srli_si128(b0, 8));
+                _mm_storel_epi64((__m128i*)(dst-1+6*2), b1);
+                _mm_storel_epi64((__m128i*)(dst-1+6*3), _mm_srli_si128(b1, 8));
+                
+                g0 = _mm_srli_si128(_mm_unpacklo_epi32(g1, r1), 1);
+                g1 = _mm_srli_si128(_mm_unpackhi_epi32(g1, r1), 1);
+                
+                _mm_storel_epi64((__m128i*)(dst-1+6*4), g0);
+                _mm_storel_epi64((__m128i*)(dst-1+6*5), _mm_srli_si128(g0, 8));
+                
+                _mm_storel_epi64((__m128i*)(dst-1+6*6), g1);
+            }
+        }
+#endif
+        
         if( blue > 0 )
         {
             for( ; bayer <= bayer_end - 2; bayer += 2, dst += 6 )
@@ -1789,7 +2012,7 @@
                 dst[-1] = (uchar)t0;
                 dst[0] = (uchar)t1;
                 dst[1] = bayer[bayer_step+1];
-
+                
                 t0 = (bayer[2] + bayer[bayer_step*2+2] + 1) >> 1;
                 t1 = (bayer[bayer_step+1] + bayer[bayer_step+3] + 1) >> 1;
                 dst[2] = (uchar)t0;
@@ -1808,7 +2031,7 @@
                 dst[1] = (uchar)t0;
                 dst[0] = (uchar)t1;
                 dst[-1] = bayer[bayer_step+1];
-
+                
                 t0 = (bayer[2] + bayer[bayer_step*2+2] + 1) >> 1;
                 t1 = (bayer[bayer_step+1] + bayer[bayer_step+3] + 1) >> 1;
                 dst[4] = (uchar)t0;
@@ -1816,7 +2039,7 @@
                 dst[2] = (uchar)t1;
             }
         }
-
+        
         if( bayer < bayer_end )
         {
             t0 = (bayer[0] + bayer[2] + bayer[bayer_step*2] +
@@ -1829,10 +2052,31 @@
             bayer++;
             dst += 3;
         }
-
+        
+        dst0[-4] = dst0[-1];
+        dst0[-3] = dst0[0];
+        dst0[-2] = dst0[1];
+        dst0[size.width*3-1] = dst0[size.width*3-4];
+        dst0[size.width*3] = dst0[size.width*3-3];
+        dst0[size.width*3+1] = dst0[size.width*3-2];
+        
         blue = -blue;
         start_with_green = !start_with_green;
     }
+    
+    size = dstmat.size();
+    dst0 = dstmat.data;
+    if( size.height > 2 )
+        for( int i = 0; i < size.width*3; i++ )
+        {
+            dst0[i] = dst0[i + dst_step];
+            dst0[i + (size.height-1)*dst_step] = dst0[i + (size.height-2)*dst_step];
+        }
+    else
+        for( int i = 0; i < size.width*3; i++ )
+        {
+            dst0[i] = dst0[i + (size.height-1)*dst_step] = 0;
+        }
 }
 
     
@@ -2132,8 +2376,9 @@
                 break;
             
             __m128i emask = _mm_set1_epi32(0x0000ffff),
-            omask = _mm_set1_epi32(0xffff0000),
-            z = _mm_setzero_si128();
+                omask = _mm_set1_epi32(0xffff0000),
+                all_ones = _mm_set1_epi16(1),
+                z = _mm_setzero_si128();
             __m128 _0_5 = _mm_set1_ps(0.5f);
             
             #define _mm_merge_epi16(a, b) \
@@ -2307,7 +2552,7 @@
                 
                 // gradNW
                 mask = _mm_cmpgt_epi16(T, gradNW);
-                ng = _mm_sub_epi16(ng, mask);
+                ng = _mm_max_epi16(_mm_sub_epi16(ng, mask), all_ones);
                 
                 __m128 ngf0, ngf1;
                 ngf0 = _mm_div_ps(_0_5, _mm_cvtloepi16_ps(ng));
@@ -2657,12 +2902,19 @@
             }
             }
             break;
+        
+        case CV_BayerBG2GRAY: case CV_BayerGB2GRAY: case CV_BayerRG2GRAY: case CV_BayerGR2GRAY:
+            if(dcn <= 0) dcn = 1;
+            CV_Assert( scn == 1 && dcn == 1 && depth == CV_8U );
+            dst.create(sz, depth);
+            Bayer2Gray_8u(src, dst, code);
+            break;    
             
         case CV_BayerBG2BGR: case CV_BayerGB2BGR: case CV_BayerRG2BGR: case CV_BayerGR2BGR:
         case CV_BayerBG2BGR_VNG: case CV_BayerGB2BGR_VNG: case CV_BayerRG2BGR_VNG: case CV_BayerGR2BGR_VNG:
             if(dcn <= 0) dcn = 3;
             CV_Assert( scn == 1 && dcn == 3 && depth == CV_8U );
-            dst.create(sz, CV_8UC3);
+            dst.create(sz, CV_MAKETYPE(depth, dcn));
             
             if( code == CV_BayerBG2BGR || code == CV_BayerGB2BGR ||
                 code == CV_BayerRG2BGR || code == CV_BayerGR2BGR )
diff -ur OpenCV-2.2.0/modules/imgproc/src/utils.cpp opencv/modules/imgproc/src/utils.cpp
--- OpenCV-2.2.0/modules/imgproc/src/utils.cpp	2010-12-05 04:35:25.000000000 +0100
+++ opencv/modules/imgproc/src/utils.cpp	2011-05-26 12:56:30.465093002 +0200
@@ -71,413 +71,164 @@
     return (CvSeq*)contour_header;
 }
 
+namespace cv
+{
 
-typedef CvStatus (CV_STDCALL * CvCopyNonConstBorderFunc)(
-    const void*, int, CvSize, void*, int, CvSize, int, int );
-
-typedef CvStatus (CV_STDCALL * CvCopyNonConstBorderFuncI)(
-    const void*, int, CvSize, CvSize, int, int );
-
-CvStatus CV_STDCALL
-icvCopyReplicateBorder_8u( const uchar* src, int srcstep, CvSize srcroi,
-                           uchar* dst, int dststep, CvSize dstroi,
-                           int top, int left, int cn, const uchar* )
+static void copyMakeBorder_8u( const uchar* src, size_t srcstep, Size srcroi,
+                               uchar* dst, size_t dststep, Size dstroi,
+                               int top, int left, int cn, int borderType )
 {
     const int isz = (int)sizeof(int);
-    int i, j;
+    int i, j, k, elemSize = 1;
+    bool intMode = false;
 
     if( (cn | srcstep | dststep | (size_t)src | (size_t)dst) % isz == 0 )
     {
-        const int* isrc = (const int*)src;
-        int* idst = (int*)dst;
-        
         cn /= isz;
-        srcstep /= isz;
-        dststep /= isz;
-
-        srcroi.width *= cn;
-        dstroi.width *= cn;
-        left *= cn;
-
-        for( i = 0; i < dstroi.height; i++, idst += dststep )
-        {
-            if( idst + left != isrc )
-                memcpy( idst + left, isrc, srcroi.width*sizeof(idst[0]) );
-            for( j = left - 1; j >= 0; j-- )
-                idst[j] = idst[j + cn];
-            for( j = left+srcroi.width; j < dstroi.width; j++ )
-                idst[j] = idst[j - cn];
-            if( i >= top && i < top + srcroi.height - 1 )
-                isrc += srcstep;
-        }
+        elemSize = isz;
+        intMode = true;
     }
-    else
-    {
-        srcroi.width *= cn;
-        dstroi.width *= cn;
-        left *= cn;
 
-        for( i = 0; i < dstroi.height; i++, dst += dststep )
-        {
-            if( dst + left != src )
-                memcpy( dst + left, src, srcroi.width );
-            for( j = left - 1; j >= 0; j-- )
-                dst[j] = dst[j + cn];
-            for( j = left+srcroi.width; j < dstroi.width; j++ )
-                dst[j] = dst[j - cn];
-            if( i >= top && i < top + srcroi.height - 1 )
-                src += srcstep;
-        }
+    AutoBuffer<int> _tab((dstroi.width - srcroi.width)*cn);
+    int* tab = _tab;
+    int right = dstroi.width - srcroi.width - left;
+    int bottom = dstroi.height - srcroi.height - top;
+    
+    for( i = 0; i < left; i++ )
+    {
+        j = borderInterpolate(i - left, srcroi.width, borderType)*cn;
+        for( k = 0; k < cn; k++ )
+            tab[i*cn + k] = j + k;
     }
-
-    return CV_OK;
-}
-
-
-static CvStatus CV_STDCALL
-icvCopyReflect101Border_8u( const uchar* src, int srcstep, CvSize srcroi,
-                            uchar* dst, int dststep, CvSize dstroi,
-                            int top, int left, int cn )
-{
-    const int isz = (int)sizeof(int);
-    int i, j, k, t, dj, tab_size, int_mode = 0;
-    const int* isrc = (const int*)src;
-    int* idst = (int*)dst, *tab;
-
-    if( (cn | srcstep | dststep | (size_t)src | (size_t)dst) % isz == 0 )
+    
+    for( i = 0; i < right; i++ )
     {
-        cn /= isz;
-        srcstep /= isz;
-        dststep /= isz;
-
-        int_mode = 1;
+        j = borderInterpolate(srcroi.width + i, srcroi.width, borderType)*cn;
+        for( k = 0; k < cn; k++ )
+            tab[(i+left)*cn + k] = j + k;
     }
 
     srcroi.width *= cn;
     dstroi.width *= cn;
     left *= cn;
+    right *= cn;
+    
+    uchar* dstInner = dst + dststep*top + left*elemSize;
 
-    tab_size = dstroi.width - srcroi.width;
-    tab = (int*)cvStackAlloc( tab_size*sizeof(tab[0]) );
-
-    if( srcroi.width == 1 )
-    {
-        for( k = 0; k < cn; k++ )
-            for( i = 0; i < tab_size; i += cn )
-                tab[i + k] = k + left;
-    }
-    else
+    for( i = 0; i < srcroi.height; i++, dstInner += dststep, src += srcstep )
     {
-        j = dj = cn;
-        for( i = left - cn; i >= 0; i -= cn )
-        {
-            for( k = 0; k < cn; k++ )
-                tab[i + k] = j + k + left;
-            if( (unsigned)(j += dj) >= (unsigned)srcroi.width )
-                j -= 2*dj, dj = -dj;
-        }
+        if( dstInner != src )
+            memcpy(dstInner, src, srcroi.width*elemSize);
         
-        j = srcroi.width - cn*2;
-        dj = -cn;
-        for( i = left; i < tab_size; i += cn )
+        if( intMode )
         {
-            for( k = 0; k < cn; k++ )
-                tab[i + k] = j + k + left;
-            if( (unsigned)(j += dj) >= (unsigned)srcroi.width )
-                j -= 2*dj, dj = -dj;
+            const int* isrc = (int*)src;
+            int* idstInner = (int*)dstInner;
+            for( j = 0; j < left; j++ )
+                idstInner[j - left] = isrc[tab[j]];
+            for( j = 0; j < right; j++ )
+                idstInner[j + srcroi.width] = isrc[tab[j + left]];
         }
-    }
-
-    if( int_mode )
-    {
-        idst += top*dststep;
-        for( i = 0; i < srcroi.height; i++, isrc += srcstep, idst += dststep )
+        else
         {
-            if( idst + left != isrc )
-                memcpy( idst + left, isrc, srcroi.width*sizeof(idst[0]) );
             for( j = 0; j < left; j++ )
-            {
-                k = tab[j]; 
-                idst[j] = idst[k];
-            }
-            for( ; j < tab_size; j++ )
-            {
-                k = tab[j];
-                idst[j + srcroi.width] = idst[k];
-            }
+                dstInner[j - left] = src[tab[j]];
+            for( j = 0; j < right; j++ )
+                dstInner[j + srcroi.width] = src[tab[j + left]];
         }
-        isrc -= srcroi.height*srcstep;
-        idst -= (top + srcroi.height)*dststep;
     }
-    else
+    
+    dstroi.width *= elemSize;
+    dst += dststep*top;
+    
+    for( i = 0; i < top; i++ )
     {
-        dst += top*dststep;
-        for( i = 0; i < srcroi.height; i++, src += srcstep, dst += dststep )
-        {
-            if( dst + left != src )
-                memcpy( dst + left, src, srcroi.width );
-            for( j = 0; j < left; j++ )
-            {
-                k = tab[j]; 
-                dst[j] = dst[k];
-            }
-            for( ; j < tab_size; j++ )
-            {
-                k = tab[j];
-                dst[j + srcroi.width] = dst[k];
-            }
-        }
-        src -= srcroi.height*srcstep;
-        dst -= (top + srcroi.height)*dststep;
+        j = borderInterpolate(i - top, srcroi.height, borderType);
+        memcpy(dst + (i - top)*dststep, dst + j*dststep, dstroi.width);
     }
-
-    for( t = 0; t < 2; t++ )
+    
+    for( i = 0; i < bottom; i++ )
     {
-        int i1, i2, di;
-        if( t == 0 )
-            i1 = top-1, i2 = 0, di = -1, j = 1, dj = 1;
-        else
-            i1 = top+srcroi.height, i2=dstroi.height, di = 1, j = srcroi.height-2, dj = -1;
-        
-        for( i = i1; (di > 0 && i < i2) || (di < 0 && i > i2); i += di )
-        {
-            if( int_mode )
-            {
-                const int* s = idst + i*dststep;
-                int* d = idst + (j+top)*dststep;
-                for( k = 0; k < dstroi.width; k++ )
-                    d[k] = s[k];
-            }
-            else
-            {
-                const uchar* s = dst + i*dststep;
-                uchar* d = dst + (j+top)*dststep;
-                for( k = 0; k < dstroi.width; k++ )
-                    d[k] = s[k];
-            }
-
-            if( (unsigned)(j += dj) >= (unsigned)srcroi.height )
-                j -= 2*dj, dj = -dj;
-        }
+        j = borderInterpolate(i + srcroi.height, srcroi.height, borderType);
+        memcpy(dst + (i + srcroi.height)*dststep, dst + j*dststep, dstroi.width);
     }
-
-    return CV_OK;
 }
 
 
-static CvStatus CV_STDCALL
-icvCopyConstBorder_8u( const uchar* src, int srcstep, CvSize srcroi,
-                       uchar* dst, int dststep, CvSize dstroi,
-                       int top, int left, int cn, const uchar* value )
+static void copyMakeConstBorder_8u( const uchar* src, size_t srcstep, Size srcroi,
+                                    uchar* dst, size_t dststep, Size dstroi,
+                                    int top, int left, int cn, const uchar* value )
 {
-    const int isz = (int)sizeof(int);
-    int i, j, k;
-    if( (cn | srcstep | dststep | (size_t)src | (size_t)dst | (size_t)value) % isz == 0 )
+    int i, j;
+    AutoBuffer<uchar> _constBuf(dstroi.width*cn);
+    uchar* constBuf = _constBuf;
+    int right = dstroi.width - srcroi.width - left;
+    int bottom = dstroi.height - srcroi.height - top;
+    
+    for( i = 0; i < dstroi.width; i++ )
     {
-        const int* isrc = (const int*)src;
-        int* idst = (int*)dst;
-        const int* ivalue = (const int*)value;
-        int v0 = ivalue[0];
-        
-        cn /= isz;
-        srcstep /= isz;
-        dststep /= isz;
-
-        srcroi.width *= cn;
-        dstroi.width *= cn;
-        left *= cn;
-
-        for( j = 1; j < cn; j++ )
-            if( ivalue[j] != ivalue[0] )
-                break;
-
-        if( j == cn )
-            cn = 1;
-
-        if( dstroi.width <= 0 )
-            return CV_OK;
-
-        for( i = 0; i < dstroi.height; i++, idst += dststep )
-        {
-            if( i < top || i >= top + srcroi.height )
-            {
-                if( cn == 1 )
-                {
-                    for( j = 0; j < dstroi.width; j++ )
-                        idst[j] = v0;
-                }
-                else
-                {
-                    for( j = 0; j < cn; j++ )
-                        idst[j] = ivalue[j];
-                    for( ; j < dstroi.width; j++ )
-                        idst[j] = idst[j - cn];
-                }
-                continue;
-            }
-
-            if( cn == 1 )
-            {
-                for( j = 0; j < left; j++ )
-                    idst[j] = v0;
-                for( j = srcroi.width + left; j < dstroi.width; j++ )
-                    idst[j] = v0;
-            }
-            else
-            {
-                for( k = 0; k < cn; k++ )
-                {
-                    for( j = 0; j < left; j += cn )
-                        idst[j+k] = ivalue[k];
-                    for( j = srcroi.width + left; j < dstroi.width; j += cn )
-                        idst[j+k] = ivalue[k];
-                }
-            }
-
-            if( idst + left != isrc )
-                for( j = 0; j < srcroi.width; j++ )
-                    idst[j + left] = isrc[j];
-            isrc += srcstep;
-        }
+        for( j = 0; j < cn; j++ )
+            constBuf[i*cn + j] = value[j];
     }
-    else
+    
+    srcroi.width *= cn;
+    dstroi.width *= cn;
+    left *= cn;
+    right *= cn;
+    
+    uchar* dstInner = dst + dststep*top + left;
+    
+    for( i = 0; i < srcroi.height; i++, dstInner += dststep, src += srcstep )
     {
-        uchar v0 = value[0];
-        
-        srcroi.width *= cn;
-        dstroi.width *= cn;
-        left *= cn;
-
-        for( j = 1; j < cn; j++ )
-            if( value[j] != value[0] )
-                break;
-
-        if( j == cn )
-            cn = 1;
-
-        if( dstroi.width <= 0 )
-            return CV_OK;
-
-        for( i = 0; i < dstroi.height; i++, dst += dststep )
-        {
-            if( i < top || i >= top + srcroi.height )
-            {
-                if( cn == 1 )
-                {
-                    for( j = 0; j < dstroi.width; j++ )
-                        dst[j] = v0;
-                }
-                else
-                {
-                    for( j = 0; j < cn; j++ )
-                        dst[j] = value[j];
-                    for( ; j < dstroi.width; j++ )
-                        dst[j] = dst[j - cn];
-                }
-                continue;
-            }
-
-            if( cn == 1 )
-            {
-                for( j = 0; j < left; j++ )
-                    dst[j] = v0;
-                for( j = srcroi.width + left; j < dstroi.width; j++ )
-                    dst[j] = v0;
-            }
-            else
-            {
-                for( k = 0; k < cn; k++ )
-                {
-                    for( j = 0; j < left; j += cn )
-                        dst[j+k] = value[k];
-                    for( j = srcroi.width + left; j < dstroi.width; j += cn )
-                        dst[j+k] = value[k];
-                }
-            }
-
-            if( dst + left != src )
-                for( j = 0; j < srcroi.width; j++ )
-                    dst[j + left] = src[j];
-            src += srcstep;
-        }
+        if( dstInner != src )
+            memcpy( dstInner, src, srcroi.width );
+        memcpy( dstInner - left, constBuf, left );
+        memcpy( dstInner + srcroi.width, constBuf, right );
     }
-
-    return CV_OK;
+    
+    dst += dststep*top;
+    
+    for( i = 0; i < top; i++ )
+        memcpy(dst + (i - top)*dststep, constBuf, dstroi.width);
+    
+    for( i = 0; i < bottom; i++ )
+        memcpy(dst + (i + srcroi.height)*dststep, constBuf, dstroi.width);
 }
 
-
-CV_IMPL void
-cvCopyMakeBorder( const CvArr* srcarr, CvArr* dstarr, CvPoint offset,
-                  int bordertype, CvScalar value )
+    
+void copyMakeBorder( const Mat& src, Mat& dst, int top, int bottom,
+                    int left, int right, int borderType, const Scalar& value )
 {
-    CvMat srcstub, *src = (CvMat*)srcarr;
-    CvMat dststub, *dst = (CvMat*)dstarr;
-    CvSize srcsize, dstsize;
-    int srcstep, dststep;
-    int pix_size, type;
-
-    if( !CV_IS_MAT(src) )
-        src = cvGetMat( src, &srcstub );
-    
-    if( !CV_IS_MAT(dst) )    
-        dst = cvGetMat( dst, &dststub );
-
-    if( offset.x < 0 || offset.y < 0 )
-        CV_Error( CV_StsOutOfRange, "Offset (left/top border width) is negative" );
-
-    if( src->rows + offset.y > dst->rows || src->cols + offset.x > dst->cols )
-        CV_Error( CV_StsBadSize, "Source array is too big or destination array is too small" );
-
-    if( !CV_ARE_TYPES_EQ( src, dst ))
-        CV_Error( CV_StsUnmatchedFormats, "" );
-
-    type = CV_MAT_TYPE(src->type);
-    pix_size = CV_ELEM_SIZE(type);
-    srcsize = cvGetMatSize(src);
-    dstsize = cvGetMatSize(dst);
-    srcstep = src->step;
-    dststep = dst->step;
-    if( srcstep == 0 )
-        srcstep = CV_STUB_STEP;
-    if( dststep == 0 )
-        dststep = CV_STUB_STEP;
-
-    bordertype &= 15;
-    if( bordertype == IPL_BORDER_REPLICATE )
-    {
-        icvCopyReplicateBorder_8u( src->data.ptr, srcstep, srcsize,
-                                   dst->data.ptr, dststep, dstsize,
-                                   offset.y, offset.x, pix_size );
-    }
-    else if( bordertype == IPL_BORDER_REFLECT_101 )
-    {
-        icvCopyReflect101Border_8u( src->data.ptr, srcstep, srcsize,
-                                   dst->data.ptr, dststep, dstsize,
-                                   offset.y, offset.x, pix_size );
-    }
-    else if( bordertype == IPL_BORDER_CONSTANT )
+    CV_Assert( top >= 0 && bottom >= 0 && left >= 0 && right >= 0 );
+    
+    dst.create( src.rows + top + bottom, src.cols + left + right, src.type() );
+    if( borderType != BORDER_CONSTANT )
+        copyMakeBorder_8u( src.data, src.step, src.size(),
+                           dst.data, dst.step, dst.size(),
+                           top, left, (int)src.elemSize(), borderType );
+    else
     {
         double buf[4];
-        cvScalarToRawData( &value, buf, src->type, 0 );
-        icvCopyConstBorder_8u( src->data.ptr, srcstep, srcsize,
-                               dst->data.ptr, dststep, dstsize,
-                               offset.y, offset.x, pix_size, (uchar*)buf );
+        scalarToRawData(value, buf, src.type());
+        copyMakeConstBorder_8u( src.data, src.step, src.size(),
+                                dst.data, dst.step, dst.size(),
+                                top, left, (int)src.elemSize(), (uchar*)buf );
     }
-    else
-        CV_Error( CV_StsBadFlag, "Unknown/unsupported border type" );
+}
+    
 }
 
-namespace cv
-{
 
-void copyMakeBorder( const Mat& src, Mat& dst, int top, int bottom,
-                     int left, int right, int borderType, const Scalar& value )
+CV_IMPL void
+cvCopyMakeBorder( const CvArr* srcarr, CvArr* dstarr, CvPoint offset,
+                  int borderType, CvScalar value )
 {
-    dst.create( src.rows + top + bottom, src.cols + left + right, src.type() );
-    CvMat _src = src, _dst = dst;
-    cvCopyMakeBorder( &_src, &_dst, Point(left, top), borderType, value );
-}
-
+    cv::Mat src = cv::cvarrToMat(srcarr), dst = cv::cvarrToMat(dstarr);
+    int left = offset.x, right = dst.cols - src.cols - left;
+    int top = offset.y, bottom = dst.rows - src.rows - top;
+    
+    CV_Assert( dst.type() == src.type() );
+    cv::copyMakeBorder( src, dst, top, bottom, left, right, borderType, value );
 }
 
 /* End of file. */
diff -ur OpenCV-2.2.0/modules/ml/src/em.cpp opencv/modules/ml/src/em.cpp
--- OpenCV-2.2.0/modules/ml/src/em.cpp	2010-12-05 04:35:25.000000000 +0100
+++ opencv/modules/ml/src/em.cpp	2011-05-26 12:57:00.719093002 +0200
@@ -581,7 +581,7 @@
 
     __BEGIN__;
 
-    cv::RNG* rng = &cv::theRNG();
+    cv::RNG rng(0xFFFFFFFF);
     int i, j, k, nsamples, dims;
     int iter = 0;
     double max_dist = DBL_MAX;
@@ -605,7 +605,7 @@
     {
         for( i = 0; i < nsamples; i++ )
             labels->data.i[i] = i*nclusters/nsamples;
-        cvRandShuffle( labels, &rng->state );
+        cvRandShuffle( labels, &rng.state );
     }
 
     for( ;; )
@@ -702,7 +702,7 @@
                 const float* s;
                 for( j = 0; j < 10; j++ )
                 {
-                    i = (*rng)(nsamples);
+                    i = rng(nsamples);
                     if( counters->data.i[labels->data.i[i]] > 1 )
                         break;
                 }
@@ -738,7 +738,7 @@
         if( counters->data.i[k] == 0 )
             for(;;)
             {
-                i = (*rng)(nsamples);
+                i = rng(nsamples);
                 j = labels->data.i[i];
                 if( counters->data.i[j] > 1 )
                 {
diff -ur OpenCV-2.2.0/modules/ml/src/gbt.cpp opencv/modules/ml/src/gbt.cpp
--- OpenCV-2.2.0/modules/ml/src/gbt.cpp	2010-12-05 04:35:25.000000000 +0100
+++ opencv/modules/ml/src/gbt.cpp	2011-05-26 12:57:00.729093002 +0200
@@ -11,10 +11,6 @@
 #define CV_CMP_FLOAT(a,b) ((a) < (b))
 static CV_IMPLEMENT_QSORT_EX( icvSortFloat, float, CV_CMP_FLOAT, float)
 
-#if ANDROID
-#define expl(x) exp(x)
-#endif
-
 //===========================================================================
 string ToString(int i)
 {
@@ -461,17 +457,17 @@
         {
             for (int i=0; i<get_len(subsample_train); ++i)
             {
-                long double exp_fk = 0;
-                long double exp_sfi = 0;
+                double exp_fk = 0;
+                double exp_sfi = 0;
                 int s_step = (sample_idx->cols > sample_idx->rows) ? 1
                              : sample_idx->step/CV_ELEM_SIZE(sample_idx->type);
                 int idx = *(sample_data + subsample_data[i]*s_step);
             
                 for (int j=0; j<class_count; ++j)
                 {
-                    long double res;
+                    double res;
                     res = current_data[idx + j*sum_response->cols];
-                    res = expl(res);
+                    res = exp(res);
                     if (j == k) exp_fk = res;
                     exp_sfi += res;
                 }
@@ -625,7 +621,7 @@
 float CvGBTrees::find_optimal_value( const CvMat* _Idx )
 {
 
-    long double gamma = (long double)0.0;
+    double gamma = (double)0.0;
 
     int* idx = _Idx->data.i;
     float* resp_data = orig_response->data.fl;
@@ -639,7 +635,7 @@
         {
             for (int i=0; i<n; ++i)
                 gamma += resp_data[idx[i]] - cur_data[idx[i]];
-            gamma /= (long double)n;
+            gamma /= (double)n;
         }; break;
 
     case ABSOLUTE_LOSS:
@@ -671,7 +667,7 @@
                 float dif = residuals[i] - r_median;
                 gamma += (delta < fabs(dif)) ? Sign(dif)*delta : dif;
             }
-            gamma /= (long double)n;
+            gamma /= (double)n;
             gamma += r_median;
             delete[] residuals;
 
@@ -680,9 +676,9 @@
     case DEVIANCE_LOSS:
         {
             float* grad_data = data->responses->data.fl;
-            long double tmp1 = 0;
-            long double tmp2 = 0;
-            long double tmp  = 0;
+            double tmp1 = 0;
+            double tmp2 = 0;
+            double tmp  = 0;
             for (int i=0; i<n; ++i)
             {
                 tmp = grad_data[idx[i]];
@@ -694,7 +690,7 @@
                 tmp2 = 1;
             }
 
-            gamma = ((long double)(class_count-1)) / (long double)class_count * (tmp1/tmp2);
+            gamma = ((double)(class_count-1)) / (double)class_count * (tmp1/tmp2);
         }; break;
 
     default: break;
diff -ur OpenCV-2.2.0/modules/ml/src/nbayes.cpp opencv/modules/ml/src/nbayes.cpp
--- OpenCV-2.2.0/modules/ml/src/nbayes.cpp	2010-12-05 04:35:25.000000000 +0100
+++ opencv/modules/ml/src/nbayes.cpp	2011-05-26 12:57:00.732093002 +0200
@@ -259,7 +259,7 @@
             det *= w->data.db[j];
 
         CV_CALL( cvDiv( NULL, w, w ));
-        c->data.db[cls] = log( det );
+        c->data.db[cls] = det > 0 ? log(det) : -700;
     }
 
     result = true;
diff -ur OpenCV-2.2.0/OpenCVModule.cmake opencv/OpenCVModule.cmake
--- OpenCV-2.2.0/OpenCVModule.cmake	2010-12-05 04:35:25.000000000 +0100
+++ opencv/OpenCVModule.cmake	2011-05-26 12:57:56.446093002 +0200
@@ -66,7 +66,7 @@
 	            )
 	    endif()
 	    set_target_properties(${the_target} PROPERTIES
-	        LINK_FLAGS "/NODEFAULTLIB:libc"
+	        LINK_FLAGS "/NODEFAULTLIB:libc /DEBUG"
 	        )
 	endif()
 
diff -ur OpenCV-2.2.0/tests/cv/src/acolor.cpp opencv/tests/cv/src/acolor.cpp
--- OpenCV-2.2.0/tests/cv/src/acolor.cpp	2010-12-05 04:35:25.000000000 +0100
+++ opencv/tests/cv/src/acolor.cpp	2011-05-26 12:46:06.837093003 +0200
@@ -1734,9 +1734,6 @@
     int bi = 0;
     int step = src->step;
 
-    memset( dst->data.ptr, 0, dst->cols*3 );
-    memset( dst->data.ptr + (dst->rows-1)*dst->step, 0, dst->cols*3 );
-
     if( fwd_code == CV_BayerRG2BGR || fwd_code == CV_BayerGR2BGR )
         bi ^= 2;
 
@@ -1745,8 +1742,12 @@
         const uchar* ptr = src->data.ptr + i*step + 1;
         uchar* dst_row = dst->data.ptr + i*dst->step + 3;
         int save_code = code;
-        dst_row[-3] = dst_row[-2] = dst_row[-1] = 0;
-        dst_row[cols*3] = dst_row[cols*3+1] = dst_row[cols*3+2] = 0;
+        if( cols <= 0 )
+        {
+            dst_row[-3] = dst_row[-2] = dst_row[-1] = 0;
+            dst_row[cols*3] = dst_row[cols*3+1] = dst_row[cols*3+2] = 0;
+            continue;
+        }
 
         for( j = 0; j < cols; j++ )
         {
@@ -1768,9 +1769,35 @@
             dst_row[j*3 + 1] = (uchar)g;
             dst_row[j*3 + (bi^2)] = (uchar)r;
         }
+        
+        dst_row[-3] = dst_row[0];
+        dst_row[-2] = dst_row[1];
+        dst_row[-1] = dst_row[2];
+        dst_row[cols*3] = dst_row[cols*3-3];
+        dst_row[cols*3+1] = dst_row[cols*3-2];
+        dst_row[cols*3+2] = dst_row[cols*3-1];
+        
         code = save_code ^ 1;
         bi ^= 2;
     }
+    
+    if( src->rows <= 2 )
+    {
+        memset( dst->data.ptr, 0, (cols+2)*3 );
+        memset( dst->data.ptr + (dst->rows-1)*dst->step, 0, (cols+2)*3 );
+    }
+    else
+    {
+        uchar* top_row = dst->data.ptr;
+        uchar* bottom_row = dst->data.ptr + dst->step*(dst->rows-1);
+        int dstep = dst->step;
+        
+        for( j = 0; j < (cols+2)*3; j++ )
+        {
+            top_row[j] = top_row[j + dstep];
+            bottom_row[j] = bottom_row[j - dstep];
+        }
+    }
 }
 
 CV_ColorBayerTest color_bayer_test;
diff -ur OpenCV-2.2.0/tests/cv/src/afloodfill.cpp opencv/tests/cv/src/afloodfill.cpp
--- OpenCV-2.2.0/tests/cv/src/afloodfill.cpp	2010-12-05 04:35:25.000000000 +0100
+++ opencv/tests/cv/src/afloodfill.cpp	2011-05-26 12:46:06.853093003 +0200
@@ -138,12 +138,12 @@
         l_diff = u_diff = cvScalarAll(0.);
     else
     {
-        CvMat m = cvMat( 1, 8, CV_64F, buf );
-        cvRandArr( rng, &m, CV_RAND_NORMAL, cvScalarAll(0), cvScalarAll(4) );
+        CvMat m = cvMat( 1, 8, CV_16S, buf );
+        cvRandArr( rng, &m, CV_RAND_NORMAL, cvScalarAll(0), cvScalarAll(32) );
         for( i = 0; i < 4; i++ )
         {
-            l_diff.val[i] = fabs(m.data.db[i]);
-            u_diff.val[i] = fabs(m.data.db[i+4]);
+            l_diff.val[i] = fabs(m.data.s[i]/16.);
+            u_diff.val[i] = fabs(m.data.s[i+4]/16.);
         }
     }
 
