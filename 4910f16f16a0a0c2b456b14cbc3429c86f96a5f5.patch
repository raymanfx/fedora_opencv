From 4910f16f16a0a0c2b456b14cbc3429c86f96a5f5 Mon Sep 17 00:00:00 2001
From: Alexander Alekhin <alexander.alekhin@intel.com>
Date: Thu, 9 Aug 2018 19:49:34 +0300
Subject: [PATCH] core(libva): support YV12 too

Added to CPU path only.
OpenCL code path still expects NV12 only (according to Intel OpenCL extension)
---
 modules/core/src/va_intel.cpp | 175 ++++++++++++++++++++++++++++++++--
 1 file changed, 169 insertions(+), 6 deletions(-)

diff --git a/modules/core/src/va_intel.cpp b/modules/core/src/va_intel.cpp
index 0a2bfd96a36..a3baa4bf0bf 100644
--- a/modules/core/src/va_intel.cpp
+++ b/modules/core/src/va_intel.cpp
@@ -324,6 +324,163 @@ static void copy_convert_bgr_to_nv12(const VAImage& image, const Mat& bgr, unsig
         dstUV += dstStepUV;
     }
 }
+
+
+static void copy_convert_yv12_to_bgr(const VAImage& image, const unsigned char* buffer, Mat& bgr)
+{
+    const float d1 = 16.0f;
+    const float d2 = 128.0f;
+
+    static const float coeffs[5] =
+        {
+            1.163999557f,
+            2.017999649f,
+            -0.390999794f,
+            -0.812999725f,
+            1.5959997177f
+        };
+
+    CV_CheckEQ(image.format.fourcc, VA_FOURCC_YV12, "Unexpected image format");
+    CV_CheckEQ(image.num_planes, 3, "");
+
+    const size_t srcOffsetY = image.offsets[0];
+    const size_t srcOffsetV = image.offsets[1];
+    const size_t srcOffsetU = image.offsets[2];
+
+    const size_t srcStepY = image.pitches[0];
+    const size_t srcStepU = image.pitches[1];
+    const size_t srcStepV = image.pitches[2];
+
+    const size_t dstStep = bgr.step;
+
+    const unsigned char* srcY_ = buffer + srcOffsetY;
+    const unsigned char* srcV_ = buffer + srcOffsetV;
+    const unsigned char* srcU_ = buffer + srcOffsetU;
+
+    for (int y = 0; y < bgr.rows; y += 2)
+    {
+        const unsigned char* srcY0 = srcY_ + (srcStepY) * y;
+        const unsigned char* srcY1 = srcY0 + srcStepY;
+
+        const unsigned char* srcV = srcV_ + (srcStepV) * y / 2;
+        const unsigned char* srcU = srcU_ + (srcStepU) * y / 2;
+
+        unsigned char* dst0 = bgr.data + (dstStep) * y;
+        unsigned char* dst1 = dst0 + dstStep;
+
+        for (int x = 0; x < bgr.cols; x += 2)
+        {
+            float Y0 = float(srcY0[x+0]);
+            float Y1 = float(srcY0[x+1]);
+            float Y2 = float(srcY1[x+0]);
+            float Y3 = float(srcY1[x+1]);
+
+            float U = float(srcU[x/2]) - d2;
+            float V = float(srcV[x/2]) - d2;
+
+            Y0 = std::max(0.0f, Y0 - d1) * coeffs[0];
+            Y1 = std::max(0.0f, Y1 - d1) * coeffs[0];
+            Y2 = std::max(0.0f, Y2 - d1) * coeffs[0];
+            Y3 = std::max(0.0f, Y3 - d1) * coeffs[0];
+
+            float ruv = coeffs[4]*V;
+            float guv = coeffs[3]*V + coeffs[2]*U;
+            float buv = coeffs[1]*U;
+
+            dst0[(x+0)*NCHANNELS+0] = saturate_cast<unsigned char>(Y0 + buv);
+            dst0[(x+0)*NCHANNELS+1] = saturate_cast<unsigned char>(Y0 + guv);
+            dst0[(x+0)*NCHANNELS+2] = saturate_cast<unsigned char>(Y0 + ruv);
+
+            dst0[(x+1)*NCHANNELS+0] = saturate_cast<unsigned char>(Y1 + buv);
+            dst0[(x+1)*NCHANNELS+1] = saturate_cast<unsigned char>(Y1 + guv);
+            dst0[(x+1)*NCHANNELS+2] = saturate_cast<unsigned char>(Y1 + ruv);
+
+            dst1[(x+0)*NCHANNELS+0] = saturate_cast<unsigned char>(Y2 + buv);
+            dst1[(x+0)*NCHANNELS+1] = saturate_cast<unsigned char>(Y2 + guv);
+            dst1[(x+0)*NCHANNELS+2] = saturate_cast<unsigned char>(Y2 + ruv);
+
+            dst1[(x+1)*NCHANNELS+0] = saturate_cast<unsigned char>(Y3 + buv);
+            dst1[(x+1)*NCHANNELS+1] = saturate_cast<unsigned char>(Y3 + guv);
+            dst1[(x+1)*NCHANNELS+2] = saturate_cast<unsigned char>(Y3 + ruv);
+        }
+    }
+}
+
+static void copy_convert_bgr_to_yv12(const VAImage& image, const Mat& bgr, unsigned char* buffer)
+{
+    const float d1 = 16.0f;
+    const float d2 = 128.0f;
+
+    static const float coeffs[8] =
+        {
+            0.256999969f,  0.50399971f,   0.09799957f,   -0.1479988098f,
+            -0.2909994125f, 0.438999176f, -0.3679990768f, -0.0709991455f
+        };
+
+    CV_CheckEQ(image.format.fourcc, VA_FOURCC_YV12, "Unexpected image format");
+    CV_CheckEQ(image.num_planes, 3, "");
+
+    const size_t dstOffsetY = image.offsets[0];
+    const size_t dstOffsetV = image.offsets[1];
+    const size_t dstOffsetU = image.offsets[2];
+
+    const size_t dstStepY = image.pitches[0];
+    const size_t dstStepU = image.pitches[1];
+    const size_t dstStepV = image.pitches[2];
+
+    unsigned char* dstY_ = buffer + dstOffsetY;
+    unsigned char* dstV_ = buffer + dstOffsetV;
+    unsigned char* dstU_ = buffer + dstOffsetU;
+
+    const size_t srcStep = bgr.step;
+
+    for (int y = 0; y < bgr.rows; y += 2)
+    {
+        unsigned char* dstY0 = dstY_ + (dstStepY) * y;
+        unsigned char* dstY1 = dstY0 + dstStepY;
+
+        unsigned char* dstV = dstV_ + (dstStepV) * y / 2;
+        unsigned char* dstU = dstU_ + (dstStepU) * y / 2;
+
+        const unsigned char* src0 = bgr.data + (srcStep) * y;
+        const unsigned char* src1 = src0 + srcStep;
+
+        for (int x = 0; x < bgr.cols; x += 2)
+        {
+            float B0 = float(src0[(x+0)*NCHANNELS+0]);
+            float G0 = float(src0[(x+0)*NCHANNELS+1]);
+            float R0 = float(src0[(x+0)*NCHANNELS+2]);
+
+            float B1 = float(src0[(x+1)*NCHANNELS+0]);
+            float G1 = float(src0[(x+1)*NCHANNELS+1]);
+            float R1 = float(src0[(x+1)*NCHANNELS+2]);
+
+            float B2 = float(src1[(x+0)*NCHANNELS+0]);
+            float G2 = float(src1[(x+0)*NCHANNELS+1]);
+            float R2 = float(src1[(x+0)*NCHANNELS+2]);
+
+            float B3 = float(src1[(x+1)*NCHANNELS+0]);
+            float G3 = float(src1[(x+1)*NCHANNELS+1]);
+            float R3 = float(src1[(x+1)*NCHANNELS+2]);
+
+            float Y0 = coeffs[0]*R0 + coeffs[1]*G0 + coeffs[2]*B0 + d1;
+            float Y1 = coeffs[0]*R1 + coeffs[1]*G1 + coeffs[2]*B1 + d1;
+            float Y2 = coeffs[0]*R2 + coeffs[1]*G2 + coeffs[2]*B2 + d1;
+            float Y3 = coeffs[0]*R3 + coeffs[1]*G3 + coeffs[2]*B3 + d1;
+
+            float U = coeffs[3]*R0 + coeffs[4]*G0 + coeffs[5]*B0 + d2;
+            float V = coeffs[5]*R0 + coeffs[6]*G0 + coeffs[7]*B0 + d2;
+
+            dstY0[x+0] = saturate_cast<unsigned char>(Y0);
+            dstY0[x+1] = saturate_cast<unsigned char>(Y1);
+            dstY1[x+0] = saturate_cast<unsigned char>(Y2);
+            dstY1[x+1] = saturate_cast<unsigned char>(Y3);
+
+            dstU[x/2] = saturate_cast<unsigned char>(U);
+            dstV[x/2] = saturate_cast<unsigned char>(V);
+        }
+    }
+}
 #endif // HAVE_VA
 
 void convertToVASurface(VADisplay display, InputArray src, VASurfaceID surface, Size size)
@@ -412,9 +569,12 @@ void convertToVASurface(VADisplay display, InputArray src, VASurfaceID surface,
         if (status != VA_STATUS_SUCCESS)
             CV_Error(cv::Error::StsError, "VA-API: vaMapBuffer failed");
 
-        CV_Assert(image.format.fourcc == VA_FOURCC_NV12);
-
-        copy_convert_bgr_to_nv12(image, m, buffer);
+        if (image.format.fourcc == VA_FOURCC_NV12)
+            copy_convert_bgr_to_nv12(image, m, buffer);
+        if (image.format.fourcc == VA_FOURCC_YV12)
+            copy_convert_bgr_to_yv12(image, m, buffer);
+        else
+            CV_Check((int)image.format.fourcc, image.format.fourcc == VA_FOURCC_NV12 || image.format.fourcc == VA_FOURCC_YV12, "Unexpected image format");
 
         status = vaUnmapBuffer(display, image.buf);
         if (status != VA_STATUS_SUCCESS)
@@ -510,9 +670,12 @@ void convertFromVASurface(VADisplay display, VASurfaceID surface, Size size, Out
         if (status != VA_STATUS_SUCCESS)
             CV_Error(cv::Error::StsError, "VA-API: vaMapBuffer failed");
 
-        CV_Assert(image.format.fourcc == VA_FOURCC_NV12);
-
-        copy_convert_nv12_to_bgr(image, buffer, m);
+        if (image.format.fourcc == VA_FOURCC_NV12)
+            copy_convert_nv12_to_bgr(image, buffer, m);
+        if (image.format.fourcc == VA_FOURCC_YV12)
+            copy_convert_yv12_to_bgr(image, buffer, m);
+        else
+            CV_Check((int)image.format.fourcc, image.format.fourcc == VA_FOURCC_NV12 || image.format.fourcc == VA_FOURCC_YV12, "Unexpected image format");
 
         status = vaUnmapBuffer(display, image.buf);
         if (status != VA_STATUS_SUCCESS)
